The way I initially approached this problem was I constructed three matchers - one that accepted an alternative list, one that took a specific right hand side, and one that just took a term. The first matcher would take all right hand sides for the start symbol. If it found a valid prefix, it called the acceptor and used its return to determine what to do next. If not, and the alternative list passed to it was empty, it returned None. However, this implementation failed in the way it checked a valid prefix. I was comparing the left hand side of a rule to the start symbol to ensure that I called the acceptor in the appropriate matcher call. Since in many grammars, the start symbol isn't exclusively used in the most top level rule (can't just check if lhs = Expr), this failed more expansive tests (test4). 

To remedy this, I tried calling the acceptor in the rhs matcher but there was still no way to check if I was at the most top level call. In many instances, I would be halfway through the derivation when the acceptor was called. Eventually, with a little help from a TA, I realized that I should be passing in my matcher as an acceptor in deeper recursive calls. This would accomplish two things: (1) it allowed me to limit my implementation to 3 functions (instead of making more to address everything after the head recursive call) and (2) and most importantly, it made sure that the initial acceptor was not being used too early. 

From here, it was simply a matter of reworking the order of my arguments and trimming the fat. I combined the rhs matcher and term matcher into one function to make my matcher_and function. This is the function I used for my acceptor as well since it returns the correct values when called on a specific rule (when calling a rule, the program has to make sure all terms of the right hand side are matched. Thus, I need this as my acceptor for all rules in the derivation except the first one). 

One more thing that I didn't consider in my initial implementation was the need to call the acceptor when the fragment was empty. My thought process was focused only on reaching the end term of the top level right hand side. While I did have a check to see if the fragment reached its end before the rule did, I didn't realize that one reason that my code was failing might have been that the matcher kept being called on an empty fragment. In hindsight, this seems like one of the first checks I should have implemented. At least in the future, I can learn from this and start any assignment by outlining the most necessary bounds program. 

I wish I would have done this in the beginning of this assignment since I ran into numerous problems initially. When I first saw the spec, I thought this would be a relatively straightforward assignment, and looking at the solution, it is. Getting there though took me far too long mainly because I was not thinking from a high-level point of view, and I did not clearly plan the logic in my code. This is what my takeaway is from the assignment - (1) make sure to formulate a clear, logical way to go about the problem (2) always establish the necessary bounds (3) try to make the code concise. 

Number 1 is important in any code but especially in functional programming. All the recursion can get very confusing very easily which is why it is so essential to keep the implementation clear and directed. The second one is a little obvious but is something that would have helped immensely if I had done it to start with. The last one comes from the fact that I initially had too many functions. This bogged down my code and made it harder to read, which was strange because usually the more helper functions, the better. In this case though, a couple of my functions were only a few lines of code. Not only was it longer to invent a new function for these few lines, but it became distracting to keep having to glance back and forth at so many functions to read the code. After all, KISS.

Oh yea and the limitations are my program fails with blind alleys, and the function signature of my parse_prefix doesn't match the one on the spec. I tried it on seasnet as well but it's the same. A couple other people had this problem though so you can't fail us all! ...Right?